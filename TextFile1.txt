dto katmaný ---
dýþ dünyaya veriyiy kontrollu sunmak için ayrý bir sýnýf 
automapper ise entity layerdeki sýnýflarýmýzdaki nesnleeri kopyalamaya yarayan bir paket mesela entitylayerdeki room sýnýfýný roomadddto
ya tek tek elle yazmadan kendisi aktarýyoru bunu de api kýsmýnda klasör acýp yaptýk 
startup tarafýna da automapper eklediðimizi belirttik ama
javada bean diye birþey vardý burada onun yerine oluþturulan bir nesneyi tekrardan automapper ile yazýyoruz iþte
----
[HttpPost]
        public IActionResult AddRoom(RoomAddDto roomAddDto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest();
            }
            var values = _mapper.Map<Room>(roomAddDto);
            _roomService.TInsert(values);

            return Ok();
        }
        bu kod yeni bir room2controller açýp if(!Modelstata.isvalid) burada boþ býraklýan bir alan varmý diye bakýyoruz bunu da 
        roomAddDto da required alanlarýmýz sayesinde yapýyoruz. sonrasýnda da var values diyip gelen roomAddDto nesnesini room nesnesine
        dönüþtürüyoruz ve eklemeyi yapýyoruz.

       ** swagger tarafýnda hata mesajlarýný gösterebiliyoruz veri girilmediði zaman ama bunu admin paneli kullanan kiþi de görmeli 
       frontend kýsmýnda da gösterebilmeliyiz o sebeple

       önce frontende de dto klasoru acýp içerisine dtolarýmýzý giriyirouz burdaki dto lar model klasorunun içerisine açtýgýmýz viewmodel
       lerin yerini tutucak oyle kullanmýycaz artýk

           <span asp-validation-for="ServiceIcon" class="text-danger"></span>
 bu ilgili property e ait hata mesajýný otomatik ekranda gösteriyor. BU sayfayý ilk açtýgýmýzda calýsmaz modelstate in içerisi boþ çünkü 

 **identity kütüphanesi**
 dataacces entity api webui bu 4 katmana ýdentity kutuphanemizi kuruyoruz
 identity kütüphanesi--kullanýcý verilerini kullanýcý bilgilerini login register iþlemlerini güvenli bir þekilde yapmamýzý saðlayan
 þifreleri hashli tutan bir microsoft kütüphanesidir
 bunu kurduktan sonra entity katmanýna iki tane sýnýf acýyoruz appuser ve approle adýnda appusera extra name surname ve city proplarýný
 yazdýk kütüphanede zaten geriye kalan cogu özellik var sonra dataaccessde contex clasýna gidip önceden dbcontexten miras alýyordu artýk
 IdentityDbcontex<Appuser,approle,int> buradan miras alacak sonra migration yapýp bu identity kütüphanesinden gelen tablolarý da veri tabanýmýzýa 
 ekleriz
 bunlarý yaptýktan sonra frontend kýsmýnda register iþlemleri için bir controller ekliycez apiyle bir baglantýmýz yok burada

    ÝDENTÝTY ÝLE KULLANICI KAYIT ÝÞLEMLERÝNÝN MANTIGINA EVDE BÝDAHA BAK 
    *** 

    **þimdi kullanýcýlarýn göreceði asýl temaya geçiyoruz ***
    ilk olarak ana index ekranýný viewcomponentlere bölücez viewcomponentler ayný partiallar gibi çaliþir ama daha özellikli halidir viewlardan
    bagýmsýzdýr kendisi kucuk bir view gibi düþün ayrýca kendi basýna veri çekebilir.
    viewcomponent parçlarýný shared de tanýmlýycaz bunlarý yaptýktan sonra bundan sonraki iþimiz bu vievcomponentlarý kullanarak onlara özel veri cekip ekrana 
    yansýtmalarý yapýcaz ilk olarak about us componentinden baslýyoruz

    about için tek tek mimariyi uyguladýk entityde olutþrurup srevice katmaný olsun dataacces katmaný olsun sonrasýnda bunun api tarafýnda controllerýnýz yazdýk ve
    frontend tarafýnda ise ayrý bir controller yazmadýk cunku view componentte göstereceðimiz için onun içiçnde cektik verileri 

    ayný iþlemleri diðer viewcomponentler içinde yaptýk ama ****VÝEWCOMPONENTLER**** sadece veri listelemek içindir post iþlemleri için tavsiye edilmiyor post yapacagýmýz iþlem için
    mesela subscribe kýsmýnda ana default controllerýmýzda bir partial oluþturup oradan devam edicez

    ***JSON WEB TOKEN***
    güvenlik için asp net core da yaptýgýmýz identity den daha önemli ama onun gibi bir de bu sayede veriler þifreli olarak geliyor jwt ile
    ilk olarak hotel projesinden ayrý olarak bi api projesi actýk onun içerisþne jwt bearer pkaetini kurduk
    sonrasýnda bunun configürasyonunu yapýcaz startup kýsmýnda

     services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(opt =>
            {
                opt.RequireHttpsMetadata = false;
                opt.TokenValidationParameters = new TokenValidationParameters()
                {
                    ValidIssuer = "http://localhost",
                    ValidAudience = "http://localhost",
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("aspnetcoreapiapi")),
                    ValidateIssuerSigningKey = true
                    ValidateLifetime = true
                };
            });
            startup kýsmýnda service kýsmýna yazdýgýmýz configirasyonlar
            /*TEK TEK ACIKLAMALARI
           * services.AddAuthentication -->> ile uygulamada bir authentication kullanýcagýmýzý belirtiyorruz
           * JwtBearerDefaults.AuthenticationScheme -->> Kullanýlacak kimlik doðrulama yönteminin JWT Bearer Token olduðunu belirtir (yani kullanýcý isteklerine token gönderecek ve sistem bu token’ý kontrol edecek).
           * .AddJwtBearer(opt => { ... })-->> bu satýrdan itibaren jwt ayarlarýný yapýyoruz
           * opt.RequireHttpsMetadata = false; -->>Ne yapar? Varsayýlan olarak HTTPS (güvenli baðlantý) zorunludur. Bu satýr, HTTPS zorunluluðunu kaldýrýr.
            Neden?
            Geliþtirme aþamasýnda (localhost’ta) HTTPS olmayan baðlantýlara da izin verilsin diye.
           * opt.TokenValidationParameters = new TokenValidationParameters() { ... }-->> JWT token’larýnýn doðrulanma kurallarýný tanýmlar.
           *ValidIssuer = "http://localhost",-->> Token’ý kim oluþturdu? sorusunun cevabýdýr.
           *ValidAudience = "http://localhost", -->> token i kimler kullanabilirin cevabý Genelde bu deðer, uygulamanýn frontend tarafý olur. Ama burada basit tutulmuþ ve localhost yazýlmýþ.
           *IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("aspnetcoreapiapi")),-->> tokený imzalatmak Bu anahtarla imzalanmayan token’lar geçersiz olur.
           *ValidateIssuerSigningKey = true, -->>Token’ý doðrularken yukarýda tanýmladýðýmýz IssuerSigningKey’i kullanarak imzayý kontrol eder.
           *ValidateLifetime = true -->> Token’ýn süresinin geçip geçmediðini kontrol eder.

            */

            sonrasýnda token olusturma sýnýfý yazýyoruz

            public string TokenCreate()
        {
            var bytes = Encoding.UTF8.GetBytes("aspnetcoreapiapi");
            SymmetricSecurityKey key = new SymmetricSecurityKey(bytes);
            SigningCredentials credentials = new SigningCredentials(key,SecurityAlgorithms.HmacSha256);
            JwtSecurityToken token = new JwtSecurityToken(issuer: "http://localhost", audience: "http://localhost", notBefore: DateTime.Now, expires: DateTime.Now.AddMinutes(3), signingCredentials: credentials);

            JwtSecurityTokenHandler handler = new JwtSecurityTokenHandler();
           return handler.WriteToken(token);

        }
        /*TEK TEK ACIKLAMALARI
        * var bytes = Encoding.UTF8.GetBytes("aspnetcoreapiapi"); -->>Bu satýrda "aspnetcoreapiapi" isimli secret key (gizli anahtar) UTF8 formatýnda byte dizisine çevriliyor.
        Bu key ile token'ý imzalayacaðýz, böylece token'ý baþkalarý uyduramaz.Burada tokenýmýzýn startupta yazdýgýmýz imzaayla ayný olmasý lazým ki öyle de ikisine de aspnetcoreapiapi 
        yazdýk
        *SymmetricSecurityKey key = new SymmetricSecurityKey(bytes);-->>Yukarýda aldýðýmýz byte dizisi, SymmetricSecurityKey haline getiriliyor. Bu nesne, token’ýn güvenliðini saðlayacak anahtarý temsil eder.
        *SigningCredentials credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);-->> Token'ý imzalarken hangi algoritmayý kullanacaðýmýzý belirtiyoruz.
        Burada HMAC-SHA256 algoritmasý kullanýlýyor. credentials artýk imzalama için hazýr.
        *JwtSecurityToken token = new JwtSecurityToken(...)-->>Bu satýrda artýk token objesini oluþturuyoruz.signingCredentials: credentials->Token bu credentials (anahtar+algoritma) ile imzalanacak
        *JwtSecurityTokenHandler handler = new JwtSecurityTokenHandler();-->>Token'ý yazýya çevirmek (string yapmak) için bir handler (yönetici) oluþturuluyor.

        */
        onun içerisindeki metoda yazdýgýmýz kodlar ise bunlar 

        --Controller Sýnýfý--
        þimdi controller yazarken [HttpGet("[action]")] bu atributun içerisine actýon yazýnda metodun ismini otamatik actiona ekler yaný url ye ekler be nereden gelen istekle calýsacagýný
        belirtir
          [HttpGet("[action]")]

        public IActionResult Test()
        {
            return Ok(new CreateToken().TokenCreate());
        }
        postman ile bunu test edicez token üretiliyor mu diye http://localhost:36323/api/Default/Test bu þekilde action ile hangi metodu kullanýcagýmýzý belirtiyoruz

        [Authorize] httpgetin üzerine bunu koyarsak bu atrribute ile o metodu güvenliðe almýs oluyoruz sadece tokeni olanlar çaliþtirabilir demke
        postman ile istek atmayý dneeyince 401 unauthorized dönüyor 
        þimdi tokenimiz ile test2 yi kullanabilmeyi görcez
        token oluþturup postman üzerinde autherization seçip key de value kýsmýnda da Bearer tokenýmýzý yazýp istek atýnca giriþ yapabilioruz

        birde admine özel token üretmeyi görücez þimdi 
        admin token üretirken farklý olarak claim oluþturucaz 
        ***************************************************** BURASI AYRI OLARAK BÝR JSON WEB TOKEN ANLATIMI PROJEMÝZDE BÝZ KULLANMIYORUZ
        projede eksiklerin giderilmesine devam ediyoruz önce about kýsmýný yazmýstýk orada kiþilerin sayýlarý görülüyordu ya personel falan oraya biz random girmiþtik sayýlarý ,þimdi ise
        sayfaya üye olan kiþi sayýlarýna göre oradaki müþteriler çaliþanlar falan deðiþecek bunun için trigger yazýcaz

        Update Abouts set RoomCount=(Select Count(*) From Rooms),StaffCount=(Select Count(*) from Staffs),CustomerCount=(Select Count(*) from Guests)
        bunu sql içerisinde yazarak roomcount ve staffcount deðerlerini staffs ve rooms
        tablomuzdan aldýk. 
        ama misafirler için ayrý bir tablomuz yoktu sadece kullanýcýlar ve rezervasyon yapanlar için vardý ama bir kiþi 5 kiþi yerine de rezervasyon yaptýgý için o tam olmuoyr misafir 
        tablosu ekliycez bide en bastna
        bunlardan sonra tamam about kýsmý güncellendi diðer tablolarn sayýsýna göre deðiþti ama her seferinde update yazmak yerine ve anlýk bunu yapamýycagýmýz için sql üzerinde trigger
        yazýcaz ekleme yaptýkca kendisi artýp acalýcak
        
        Create Trigger RoomIncrease ---> triggera veridðimiz isim 
        on Rooms -->nereye veri eklenirse triggerýn calýscagýný belirtiyoruz 
        after insert
        as
        Update Abouts set RoomCount =RoomCount+1 -->sonra ayný yukardaki gibi bu komut calýýsyor iþte
        ----> cok basit bir mantýgý var trigger yazmanýn yukardaki gibi bu trigger room tablosunun tetikleyiciler klasorune ekleniyor
        ******** Burada da about kýsmýný tamamladýk trigger yazarak falan daha güzel oldu

        sonrasýnda iletiþim sayfasý ekledik birtane yine tek tek contact sýnýfý acýp entity de katmanlý mimariye ekledik sonrasýnda düzenledik 

        þimdi de 







